#!/bin/bash

# Hetzner Cloud CLI
# A simple command-line interface for managing Hetzner Cloud servers

set -e

# Load environment variables from .env if it exists
if [ -f .env ]; then
    export $(cat .env | grep -v '^#' | xargs)
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

# Check if API token is set
check_api_token() {
    if [ -z "$HETZNER_API_TOKEN" ]; then
        print_error "HETZNER_API_TOKEN is not set"
        echo "Please set your Hetzner Cloud API token in .env file or:"
        echo "  export HETZNER_API_TOKEN='your-api-token-here'"
        exit 1
    fi
}

# Base URL for Hetzner Cloud API
API_BASE="https://api.hetzner.cloud/v1"

# Show help
show_help() {
    cat << EOF
Hetzner Cloud CLI - Manage your Hetzner Cloud servers

Usage: hetzner <command> [options]

Commands:
  list                    List all servers
  create                  Create a new server
  delete <id>            Delete a server by ID
  info <id>              Show detailed info about a server
  ssh <id>               SSH into a server by ID
  run <id>               Install and run Conduit on a server
  stats <id>             Show running Conduit stats for a server
  report                 Generate stats report for all servers
  help                   Show this help message

Examples:
  hetzner list
  hetzner create
  hetzner delete 118294424
  hetzner info 118294424
  hetzner ssh 118294424
  hetzner run 118294424
  hetzner stats 118294424
  hetzner report

Configuration:
  Set your API token and defaults in .env file:
    HETZNER_API_TOKEN=your-token
    SERVER_TYPE=cpx11
    LOCATION=ash
    IMAGE=ubuntu-22.04
    SSH_KEY_NAME=msamadi

EOF
}

# List all servers
list_servers() {
    check_api_token

    print_info "Fetching servers..."

    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers")

    # Check for errors
    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Failed to fetch servers: $ERROR_MESSAGE"
        exit 1
    fi

    # Count servers
    SERVER_COUNT=$(echo "$RESPONSE" | jq '.servers | length')

    if [ "$SERVER_COUNT" -eq 0 ]; then
        echo "No servers found."
        exit 0
    fi

    echo ""
    echo -e "${CYAN}Your Servers (${SERVER_COUNT} total):${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%-12s %-25s %-16s %-12s %-15s %s\n" "ID" "NAME" "IP" "TYPE" "LOCATION" "STATUS"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    echo "$RESPONSE" | jq -r '.servers[] |
        [.id, .name, .public_net.ipv4.ip, .server_type.name, .datacenter.location.name, .status] |
        @tsv' | while IFS=$'\t' read -r id name ip type location status; do

        # Color status
        if [ "$status" = "running" ]; then
            STATUS="${GREEN}●${NC} running"
        elif [ "$status" = "off" ]; then
            STATUS="${RED}●${NC} off"
        else
            STATUS="${YELLOW}●${NC} $status"
        fi

        printf "%-12s %-25s %-16s %-12s %-15s %b\n" "$id" "$name" "$ip" "$type" "$location" "$STATUS"
    done

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
}

# Create a new server
create_server() {
    check_api_token

    # Use defaults from env or ask
    SERVER_NAME="${SERVER_NAME:-node-$(date +%s)}"
    SERVER_TYPE="${SERVER_TYPE:-cpx11}"
    LOCATION="${LOCATION:-ash}"
    IMAGE="${IMAGE:-ubuntu-22.04}"

    # Build the JSON payload
    JSON_PAYLOAD=$(cat <<EOF
{
  "name": "$SERVER_NAME",
  "server_type": "$SERVER_TYPE",
  "location": "$LOCATION",
  "image": "$IMAGE",
  "start_after_create": true
}
EOF
)

    # Add SSH key if specified
    if [ -n "$SSH_KEY_NAME" ]; then
        print_info "Looking up SSH key: $SSH_KEY_NAME"
        SSH_KEY_ID=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
            "$API_BASE/ssh_keys" | \
            jq -r ".ssh_keys[] | select(.name==\"$SSH_KEY_NAME\") | .id")

        if [ -n "$SSH_KEY_ID" ]; then
            JSON_PAYLOAD=$(echo "$JSON_PAYLOAD" | jq ". + {ssh_keys: [$SSH_KEY_ID]}")
        else
            print_warning "SSH key '$SSH_KEY_NAME' not found"
        fi
    fi

    print_info "Creating server..."
    echo "  Name:        $SERVER_NAME"
    echo "  Type:        $SERVER_TYPE"
    echo "  Location:    $LOCATION"
    echo "  Image:       $IMAGE"
    echo ""

    # Create the server
    RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$JSON_PAYLOAD" \
        "$API_BASE/servers")

    # Check if request was successful
    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Failed to create server: $ERROR_MESSAGE"
        exit 1
    fi

    # Extract server information
    SERVER_ID=$(echo "$RESPONSE" | jq -r '.server.id')
    SERVER_IPV4=$(echo "$RESPONSE" | jq -r '.server.public_net.ipv4.ip')
    ROOT_PASSWORD=$(echo "$RESPONSE" | jq -r '.root_password')

    print_success "Server created successfully!"
    echo ""
    echo "Server Details:"
    echo "  ID:          $SERVER_ID"
    echo "  Name:        $SERVER_NAME"
    echo "  IPv4:        $SERVER_IPV4"
    if [ "$ROOT_PASSWORD" != "null" ] && [ -n "$ROOT_PASSWORD" ]; then
        echo "  Root Pass:   $ROOT_PASSWORD"
    fi
    echo ""
    print_info "Waiting for server to become available..."

    # Wait for server to be running
    MAX_ATTEMPTS=60
    ATTEMPT=0
    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
        STATUS=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
            "$API_BASE/servers/$SERVER_ID" | jq -r '.server.status')

        if [ "$STATUS" = "running" ]; then
            print_success "Server is now running!"
            echo ""
            echo "Connect using: ssh root@$SERVER_IPV4"
            exit 0
        fi

        echo -n "."
        sleep 2
        ATTEMPT=$((ATTEMPT + 1))
    done

    print_warning "Server is taking longer than expected to start."
}

# Delete a server
delete_server() {
    check_api_token

    if [ -z "$1" ]; then
        print_error "Server ID is required"
        echo "Usage: hetzner delete <server-id>"
        exit 1
    fi

    SERVER_ID=$1

    # Get server info first
    print_info "Fetching server info..."
    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Server not found: $ERROR_MESSAGE"
        exit 1
    fi

    SERVER_NAME=$(echo "$RESPONSE" | jq -r '.server.name')
    SERVER_IP=$(echo "$RESPONSE" | jq -r '.server.public_net.ipv4.ip')

    echo ""
    echo -e "${YELLOW}WARNING: You are about to delete:${NC}"
    echo "  ID:     $SERVER_ID"
    echo "  Name:   $SERVER_NAME"
    echo "  IP:     $SERVER_IP"
    echo ""
    read -p "Are you sure you want to delete this server? (yes/no): " CONFIRM

    if [ "$CONFIRM" != "yes" ]; then
        echo "Deletion cancelled."
        exit 0
    fi

    print_info "Deleting server..."

    DELETE_RESPONSE=$(curl -s -X DELETE \
        -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$DELETE_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$DELETE_RESPONSE" | jq -r '.error.message')
        print_error "Failed to delete server: $ERROR_MESSAGE"
        exit 1
    fi

    print_success "Server deleted successfully!"
}

# Show server info
show_server_info() {
    check_api_token

    if [ -z "$1" ]; then
        print_error "Server ID is required"
        echo "Usage: hetzner info <server-id>"
        exit 1
    fi

    SERVER_ID=$1

    print_info "Fetching server info..."
    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Server not found: $ERROR_MESSAGE"
        exit 1
    fi

    echo ""
    echo -e "${CYAN}Server Details:${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "$RESPONSE" | jq -r '
        "ID:           \(.server.id)",
        "Name:         \(.server.name)",
        "Status:       \(.server.status)",
        "IPv4:         \(.server.public_net.ipv4.ip)",
        "IPv6:         \(.server.public_net.ipv6.ip)",
        "Type:         \(.server.server_type.name)",
        "Cores:        \(.server.server_type.cores)",
        "Memory:       \(.server.server_type.memory)GB",
        "Disk:         \(.server.server_type.disk)GB",
        "Location:     \(.server.datacenter.location.name)",
        "Datacenter:   \(.server.datacenter.name)",
        "Image:        \(.server.image.name)",
        "Created:      \(.server.created)"
    '
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
}

# SSH into a server
ssh_to_server() {
    check_api_token

    if [ -z "$1" ]; then
        print_error "Server ID is required"
        echo "Usage: hetzner ssh <server-id>"
        exit 1
    fi

    SERVER_ID=$1

    print_info "Fetching server IP..."
    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Server not found: $ERROR_MESSAGE"
        exit 1
    fi

    SERVER_IP=$(echo "$RESPONSE" | jq -r '.server.public_net.ipv4.ip')
    SERVER_NAME=$(echo "$RESPONSE" | jq -r '.server.name')

    print_info "Connecting to $SERVER_NAME ($SERVER_IP)..."
    ssh root@$SERVER_IP
}

# Run Conduit on a server
run_conduit() {
    check_api_token

    if [ -z "$1" ]; then
        print_error "Server ID is required"
        echo "Usage: hetzner run <server-id>"
        exit 1
    fi

    SERVER_ID=$1

    print_info "Fetching server IP..."
    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Server not found: $ERROR_MESSAGE"
        exit 1
    fi

    SERVER_IP=$(echo "$RESPONSE" | jq -r '.server.public_net.ipv4.ip')
    SERVER_NAME=$(echo "$RESPONSE" | jq -r '.server.name')

    print_info "Installing Conduit on $SERVER_NAME ($SERVER_IP)..."
    print_info "Using default settings (max-clients: 200, bandwidth: 5 Mbps)"
    echo ""

    # Run the conduit installation script on the remote server
    # Full output is saved to a log file; only a progress indicator is shown
    LOG_FILE="/tmp/conduit-install-$SERVER_ID.log"

    ( ssh -o StrictHostKeyChecking=no root@$SERVER_IP 'yes "" | curl -sL https://raw.githubusercontent.com/SamNet-dev/conduit-manager/main/conduit.sh | sudo bash' > "$LOG_FILE" 2>&1 & SSH_PID=$! ; sleep 180 ; kill $SSH_PID 2>/dev/null ) &
    BG_PID=$!

    # Show a simple progress spinner while the install runs
    SPIN='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    while kill -0 $BG_PID 2>/dev/null; do
        for (( i=0; i<${#SPIN}; i++ )); do
            kill -0 $BG_PID 2>/dev/null || break
            printf "\r  ${SPIN:$i:1} Installing..."
            sleep 0.2
        done
    done
    wait $BG_PID 2>/dev/null || true
    printf "\r                    \r"

    echo ""
    print_success "Conduit installation completed on $SERVER_NAME!"
    print_info "Full install log: $LOG_FILE"
    echo ""
    echo "Use './hetzner stats $SERVER_ID' to view performance metrics"
}

# Show Conduit stats for a server
stats_conduit() {
    check_api_token

    if [ -z "$1" ]; then
        print_error "Server ID is required"
        echo "Usage: hetzner stats <server-id>"
        exit 1
    fi

    SERVER_ID=$1

    # Fetch server IP
    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers/$SERVER_ID")

    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Server not found: $ERROR_MESSAGE"
        exit 1
    fi

    SERVER_IP=$(echo "$RESPONSE" | jq -r '.server.public_net.ipv4.ip')
    SERVER_NAME=$(echo "$RESPONSE" | jq -r '.server.name')

    # Get Conduit application stats by running 'conduit stats' on the remote server
    # Temporarily disable exit on error for this command
    set +e

    # Use a timeout wrapper to kill SSH after 5 seconds and capture stats output
    STATS=$(( ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$SERVER_IP 'conduit stats 2>/dev/null' & SSH_PID=$! ; sleep 5 ; kill $SSH_PID 2>/dev/null ; wait $SSH_PID 2>/dev/null ) 2>&1 | grep "^\[STATS\]" | head -n 2 )

    RESULT_CODE=$?
    set -e

    # If we got stats, show them
    if [ -n "$STATS" ]; then
        echo "$STATS"
    else
        print_error "Could not retrieve Conduit stats from $SERVER_NAME ($SERVER_IP)"
        echo "Make sure Conduit is installed and running on this server."
        exit 1
    fi
}

# Generate stats report for all servers
report_stats() {
    check_api_token

    print_info "Fetching all servers..."

    RESPONSE=$(curl -s -H "Authorization: Bearer $HETZNER_API_TOKEN" \
        "$API_BASE/servers")

    # Check for errors
    if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
        ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
        print_error "Failed to fetch servers: $ERROR_MESSAGE"
        exit 1
    fi

    # Get list of server IDs, names, and IPs as arrays
    IFS=$'\n' read -d '' -ra SERVER_IDS < <(echo "$RESPONSE" | jq -r '.servers[] | .id') || true
    IFS=$'\n' read -d '' -ra SERVER_NAMES < <(echo "$RESPONSE" | jq -r '.servers[] | .name') || true
    IFS=$'\n' read -d '' -ra SERVER_IPS < <(echo "$RESPONSE" | jq -r '.servers[] | .public_net.ipv4.ip') || true

    SERVER_COUNT=${#SERVER_IDS[@]}

    if [ $SERVER_COUNT -eq 0 ]; then
        echo "No servers found."
        exit 0
    fi

    # Create report header
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    REPORT_FILE="conduit-report-$(date '+%Y%m%d-%H%M%S').txt"

    echo "═══════════════════════════════════════════════════════════════════" > "$REPORT_FILE"
    echo "                   CONDUIT CLUSTER STATS REPORT                    " >> "$REPORT_FILE"
    echo "                   Generated: $TIMESTAMP                           " >> "$REPORT_FILE"
    echo "═══════════════════════════════════════════════════════════════════" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"

    # Display header to console
    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}                   CONDUIT CLUSTER STATS REPORT                    ${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════════${NC}"
    echo ""

    TOTAL_SERVERS=0
    RUNNING_SERVERS=0
    TOTAL_CONNECTING=0
    TOTAL_CONNECTED=0
    TOTAL_UP=0
    TOTAL_DOWN=0

    # Disable exit on error for the entire loop
    set +e

    FULL_OUTPUT=""

    # Iterate through each server
    for i in "${!SERVER_IDS[@]}"; do
        SERVER_ID="${SERVER_IDS[$i]}"
        SERVER_NAME="${SERVER_NAMES[$i]}"
        SERVER_IP="${SERVER_IPS[$i]}"

        TOTAL_SERVERS=$((TOTAL_SERVERS + 1))

        print_info "Checking server $TOTAL_SERVERS/$SERVER_COUNT: $SERVER_NAME"

        OUTPUT="Server: $SERVER_NAME (ID: $SERVER_ID, IP: $SERVER_IP)\n"
        OUTPUT+="───────────────────────────────────────────────────────────────────\n"

        # Check if Conduit is installed first
        CONDUIT_CHECK=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$SERVER_IP 'command -v conduit >/dev/null 2>&1 && echo "installed" || echo "not_installed"' 2>/dev/null || echo "not_installed")

        if [ "$CONDUIT_CHECK" = "not_installed" ]; then
            OUTPUT+="Status: Conduit not installed\n"
        else
            # Conduit is installed, try to get stats
            # Run in background and kill after 5 seconds
            ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@$SERVER_IP 'conduit stats 2>/dev/null' > /tmp/conduit-stats-$SERVER_ID.tmp 2>&1 &
            SSH_PID=$!
            sleep 5
            kill $SSH_PID 2>/dev/null || true
            wait $SSH_PID 2>/dev/null || true

            STATS=$(grep "^\[STATS\]" /tmp/conduit-stats-$SERVER_ID.tmp 2>/dev/null | head -n 1 || echo "")
            rm -f /tmp/conduit-stats-$SERVER_ID.tmp

            if [ -n "$STATS" ]; then
                OUTPUT+="$STATS\n"
                RUNNING_SERVERS=$((RUNNING_SERVERS + 1))

                # Extract metrics (simple parsing)
                CONNECTING=$(echo "$STATS" | grep -oE "Connecting: [0-9]+" | grep -oE "[0-9]+" || echo "0")
                CONNECTED=$(echo "$STATS" | grep -oE "Connected: [0-9]+" | grep -oE "[0-9]+" || echo "0")

                TOTAL_CONNECTING=$((TOTAL_CONNECTING + CONNECTING))
                TOTAL_CONNECTED=$((TOTAL_CONNECTED + CONNECTED))
            else
                OUTPUT+="Status: Conduit running - stats not available yet\n"
                RUNNING_SERVERS=$((RUNNING_SERVERS + 1))
            fi
        fi

        OUTPUT+="\n"
        FULL_OUTPUT+="$OUTPUT"

        # Print to console only
        echo -e "$OUTPUT"
    done

    # Write full output to file
    echo -e "$FULL_OUTPUT" >> "$REPORT_FILE"

    # Re-enable exit on error
    set -e

    # Summary
    echo "═══════════════════════════════════════════════════════════════════" | tee -a "$REPORT_FILE"
    echo "                           SUMMARY                                 " | tee -a "$REPORT_FILE"
    echo "═══════════════════════════════════════════════════════════════════" | tee -a "$REPORT_FILE"
    echo "Total Servers:      $TOTAL_SERVERS" | tee -a "$REPORT_FILE"
    echo "Running Conduit:    $RUNNING_SERVERS" | tee -a "$REPORT_FILE"
    echo "Total Connecting:   $TOTAL_CONNECTING" | tee -a "$REPORT_FILE"
    echo "Total Connected:    $TOTAL_CONNECTED" | tee -a "$REPORT_FILE"
    echo "═══════════════════════════════════════════════════════════════════" | tee -a "$REPORT_FILE"
    echo "" | tee -a "$REPORT_FILE"

    print_success "Report saved to: $REPORT_FILE"
}

# Main command router
case "${1:-help}" in
    list)
        list_servers
        ;;
    create)
        create_server
        ;;
    delete)
        delete_server "$2"
        ;;
    info)
        show_server_info "$2"
        ;;
    ssh)
        ssh_to_server "$2"
        ;;
    run)
        run_conduit "$2"
        ;;
    stats)
        stats_conduit "$2"
        ;;
    report)
        report_stats
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo ""
        show_help
        exit 1
        ;;
esac
